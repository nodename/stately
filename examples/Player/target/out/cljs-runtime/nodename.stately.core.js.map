{"version":3,"sources":["nodename/stately/core.cljs"],"mappings":"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","names":["nodename.stately.core/get-ns","fsm","cljs.core/namespace","cljs.core/first","cljs.core/keys","nodename.stately.core/transform-kw","kw","orig-ns","ns","cljs.core._EQ_","cljs.core.keyword","cljs.core/name","nodename.stately.core/clone-fsm","p1__68187#","selector","com.rpl.specter/walker","cljs.core/keyword?","transform-fn","com.rpl.specter.impl/compiled-transform*","info__19105__auto__","nodename.stately.core/pathcache68194","info68195","com.rpl.specter.impl/magic-precompilation","com.rpl.specter.impl/->LocalSym","precompiled68196","com.rpl.specter.impl/cached-path-info-precompiled","dynamic?__19106__auto__","com.rpl.specter.impl/cached-path-info-dynamic?","G__68197","nodename.stately.core/leaves-of-active","active","nodename.stately.tree/active-states","leaves","s","s-has-child?","p1__68198#","cljs.core/some","nodename.stately.tree/super","cljs.core/rest","cljs.core.conj","nodename.stately.core/bubble-up","state","trigger","or__5002__auto__","nodename.stately.comms/lookup-handler","nodename.stately.core/dispatch-transition","event-v","bubble-states","p1__68205#","cljs.core.map","p1__68206#","cljs.core.remove","cljs.core/set","seq__68207","cljs.core/seq","chunk__68208","count__68209","i__68210","temp__5804__auto__","cljs.core/chunked-seq?","c__5525__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","cljs.core/count","cljs.core/next","new-event-v","cljs.core/vec","cljs.core.concat","nodename.stately.comms/dispatch","var_args","args__5732__auto__","len__5726__auto__","i__5727__auto__","argseq__5733__auto__","cljs.core/IndexedSeq","nodename.stately.core/merge-no-clobber","seq68211","self__5712__auto__","maps","f","val0","val1","nodename.stately.comms.error","cljs.core.apply","cljs.core/merge-with","nodename.stately.core/start-app","middleware","state-machines","root-fsm-key","nodename.stately.tree/set-state-tree!","fsms","cljs.core/vals","obtain","prop","p1__68212#","cljs.core.get","all-actions","all-activities","all-transitions","all-states","all-start-states","cljs.core/nil?","p1__68213#","chart-data","nodename.stately.chart/register-statechart","app-start-state","nodename.stately.chart/get-start-state","active-states","nodename.stately.chart/enter-state","nodename.stately.tree/set-active-states!","nodename.stately.comms/run-queue"],"sourcesContent":["(ns nodename.stately.core\n  (:require [clojure.string :refer [blank?]]\n            [com.rpl.specter :as s]\n            [nodename.stately.comms :refer [dispatch run-queue error lookup-handler]]\n            [nodename.stately.tree :refer [super\n                                           active-states\n                                           set-active-states!\n                                           set-state-tree!]]\n            [nodename.stately.chart :refer [get-start-state\n                                            enter-state\n                                            register-statechart]]))\n\n\n\n;; CLONE FSM ;;;;;;;;;;;;;;;;;;;;\n\n\n\n(defn- get-ns\n  [fsm]\n  (namespace (first (keys (:states fsm)))))\n\n(defn- transform-kw\n  [kw orig-ns ns]\n  (if (= (namespace kw) orig-ns)\n    (keyword ns (name kw))\n    kw))\n\n(defn clone-fsm\n  \"Make a copy of fsm, replacing its namespace in every keyword with ns\"\n  [fsm ns]\n  (let [selector (s/walker keyword?)\n        orig-ns (get-ns fsm)\n        transform-fn #(transform-kw % orig-ns ns)]\n    (s/transform selector transform-fn fsm)))\n\n\n\n;; DISPATCH ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n\n(defn- leaves-of-active\n  \"Currently active states that have no currently active child states\"\n  []\n  (loop [active (active-states)\n         leaves []]\n    (let [s (first active)]\n      (if (nil? s)\n        leaves\n        (let [s-has-child? (some #(= s (super %)) (rest active))]\n          (recur (rest active)\n                 (if s-has-child?\n                   leaves\n                   (conj leaves s))))))))\n\n\n(defn- bubble-up\n  \"Find first ancestor state for which the transition key [state trigger] is registered\"\n  [state trigger]\n  (loop [state state]\n    (if (or (nil? state)\n            (lookup-handler [state trigger]))\n      state\n      (recur (super state)))))\n\n\n(defn dispatch-transition\n  \"Bubble up the state hierarchy from the leaf active states\n  to states that implement the transition, and dispatch\"\n  [event-v]\n  (let [trigger (first event-v)\n        bubble-states (->> (leaves-of-active)\n                           (map #(bubble-up % trigger))\n                           (remove #(nil? %))\n                           ;; remove duplicates:\n                           set)]\n    (doseq [state bubble-states]\n      (let [new-event-v (vec (concat [[state trigger]] (rest event-v)))]\n        (dispatch new-event-v)))))\n\n\n\n;; MAIN ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n\n(defn- merge-no-clobber\n  \"Merge the maps but go nuts if a key is repeated\"\n  [& maps]\n  (let [f (fn [val0 val1] (error \"Clobbering a handler! \" val0 \" \" val1))]\n    (apply merge-with f maps)))\n\n\n(defn start-app\n  [middleware state-machines root-fsm-key]\n  (set-state-tree! state-machines root-fsm-key)\n\n  (let [fsms (vals state-machines)\n        obtain (fn [prop]\n                 (apply merge-no-clobber\n                        (map #(get % prop) fsms)))\n\n        all-actions (obtain :actions)\n        all-activities (obtain :activities)\n        all-transitions (obtain :transitions)\n        all-states (obtain :states)\n        all-start-states (remove nil? (map #(get % :start-state) fsms))\n\n        chart-data {:all-actions all-actions\n                    :all-activities all-activities\n                    :all-transitions all-transitions\n                    :all-states all-states\n                    :all-start-states all-start-states}]\n\n    (register-statechart middleware chart-data)\n\n    (let [app-start-state (get-start-state root-fsm-key all-start-states)\n          active-states (enter-state app-start-state\n                                     [] #{} chart-data)]\n      (set-active-states! active-states)))\n\n  (run-queue))\n"]}