{"version":3,"sources":["nodename/stately/communications/impl/middleware.cljs"],"mappings":";AAGA;;;;;;;;;;;uDAAA,vDAAMA,sHAUHC;AAVH,AAWE,qFACGC,OAAOC;AADV,AAEE,SAAA,AAAAC,LAAMC,qBAASH;IACTI,SAAQ,CAACL,wCAAAA,sDAAAA,hBAAQI,mCAAAA,hCAAGF,mCAAAA;AAD1B,AAEE,GAAI,WAAA,VAAMG;AACR,iJAAA,1IAACC;;AACD,GAAA,GAAQ,CAAYF,OAAGC;AACrB,OAACE,sBAAON,OAAOI;;AADjB","names":["nodename.stately.communications.impl.middleware/pure","handler","app-db","event-vec","cljs.core/deref","db","new-db","nodename.stately.communications.impl.logging.error","cljs.core/reset!"],"sourcesContent":["(ns nodename.stately.communications.impl.middleware\n  (:require [nodename.stately.communications.impl.logging :refer [warn error]]))\n\n(defn pure\n  \"Acts as an adaptor, allowing handlers to be writen as pure functions.\n  The re-frame router passes the `app-db` atom as the first parameter to any handler.\n  This middleware adapts that atom to be the value within the atom.\n  If you strip away the error/efficiency checks, this middleware is doing:\n     (reset! app-db (handler @app-db event-vec))\n  You don't have to use this middleware directly. It is automatically applied to\n  your handler's middleware when you use \\\"register-handler\\\".\n  In fact, the only way to by-pass automatic use of \\\"pure\\\" in your middleware\n  is to use the low level registration function \\\"re-frame.handlers/register-handler-base\\\"\"\n  [handler]\n  (fn pure-handler\n    [app-db event-vec]\n    (let [db      @app-db\n          new-db  (handler db event-vec)]\n      (if (nil? new-db)\n        (error \"your pure handler returned nil. It should return the new db state.\")\n        (if-not (identical? db new-db)\n          (reset! app-db new-db))))))"]}